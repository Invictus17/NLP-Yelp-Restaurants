---
title: "Mixed Clustering"
author: "Arunav Saikia"
output: github_document
---
<h2> Getting Ready </h2>
**Set working directory**
```{r}
setwd("/Users/arunavsaikia/Documents/GitHub/NLP-Yelp-Restaurants/Restaurant Clustering/")
```
**Explore the data**

Read data and cast variables appropriately. The different data types are :

* Continuous
* Ordinal
* Nominal
```{r}

df <- read.csv('../data/clusteringAD_new.csv')
df_subset <- df[,c(37,38,39,40)]
df_subset$rating <- as.ordered(df_subset$rating)
df_subset$expensivenss <- as.ordered(df_subset$expensivenss)
summary(df_subset)

```
<h2> Calculating Distance Metric </h2>

**Gower Distance**

In order for a yet-to-be-chosen algorithm to group observations together, we first need to define some notion of (dis)similarity between observations. A popular choice for clustering is Euclidean distance. However, Euclidean distance is only valid for continuous variables, and thus is not applicable here. In order for a clustering algorithm to yield sensible results, we have to use a distance metric that can handle mixed data types. In this case, we will use something called Gower distance.[1]

Concept of Gower distance - For each variable type, a particular distance metric that works well for that type is used and scaled to fall between 0 and 1.
```{r}
library(cluster) 
gower.dist <- daisy(df_subset, metric = c("gower"))
summary(gower.dist)
```
**Look at similar/dissimilar restaurants**

As a sanity check, to make sure the metric is working, we can check the most similar and dissimilar pairs in terms of the Gower distance. Similar pairs will have similar features and for pairs which are dissimilar the features will be completely different
```{r}
gower_mat <- as.matrix(gower.dist)

# Output most similar pair

df_subset[
  which(gower_mat == min(gower_mat[gower_mat != min(gower_mat)]),
        arr.ind = TRUE)[1, ], ]
# Output most dissimilar pair

df_subset[
  which(gower_mat == max(gower_mat[gower_mat != max(gower_mat)]),
        arr.ind = TRUE)[1, ], ]
```
<h2>Algorithm 1 - Partitioning Around Medoids</h2>

***What is PAM?***

Partitioning around medoids is an iterative clustering procedure with the following steps:

* Choose k random entities to become the mediods
* Assign every entity to its closest medoid (using our custom distance matrix in this case)
* For each cluster, identify the observation that would yield the lowest average distance if it were to be re-assigned as the medoid. If so, make this observation the new medoid.
* If at least one medoid has changed, return to step 2. Otherwise, end the algorithm.

Both k-means and k-medoids approaches are identical, except k-means has cluster centers defined by Euclidean distance (i.e., centroids), while cluster centers for PAM are restricted to be the observations themselves (i.e., medoids).

***Silhouette Analysis***

We then look at the silhouette width - a validation metric which is an aggregated measure of how similar an observation is to its own cluster compared its closest neighboring cluster. The metric can range from -1 to 1, where higher values are better. 

Increasing number of clusters will almost always lead to better silhouette score, but that does not make sense or satisfy the objective. Long story short, we should pick a meaningful number that is simple and equally as good.
```{r}
max_clusters <- 20
sil_width <- c(NA)

for(i in 2:max_clusters){
  
  pam_fit <- pam(gower.dist,
                 diss = TRUE,
                 k = i)
  
  sil_width[i] <- pam_fit$silinfo$avg.width
  
}

# Plot sihouette width (higher is better)

plot(1:max_clusters, sil_width,
     xlab = "Number of clusters",
     ylab = "Silhouette Width")
lines(1:max_clusters, sil_width)

```

***Cluster Interpretation via descriptive statistics***

After running the algorithm and selecting 7 clusters, we can interpret the clusters by running summary on each cluster. 
```{r}
library(dplyr)
num_clusters = 7
pam_fit <- pam(gower.dist,
                 diss = TRUE,
                 k = num_clusters)

pam_results <- df_subset %>%
  mutate(cluster = pam_fit$clustering) %>%
  group_by(cluster) %>%
  do(the_summary = summary(.))

pam_results$the_summary
```
***Visualizing the clusters*** 

Although not perfect, colors are mostly located in similar areas, confirming the relevancy of the segmentation
```{r}

library(Rtsne)
library(ggplot2)
library(dplyr)


tsne_obj <- Rtsne(gower.dist, is_distance = TRUE)

tsne_data <- tsne_obj$Y %>%
  data.frame() %>%
  setNames(c("X", "Y")) %>%
  mutate(cluster = factor(pam_fit$clustering),
         name = df_subset$name)

ggplot(aes(x = X, y = Y), data = tsne_data) +
  geom_point(aes(color = cluster))
```
<h2> Algorithm 2 - Hierarchical Clustering </h2>

**What is Hierarchical Clustering?**

1. **_Agglomerative clustering_**: Also known as **AGNES (Agglomerative Nesting)** works in a bottom-up manner. Each object is initially considered as a single-element cluster (leaf). At each step of the algorithm, the two clusters that are the most similar are combined into a new bigger cluster (nodes). This procedure is iterated until all points are member of just one single big cluster (root) (see figure below)

2. **_Divisive hierarchical clustering_**: It’s also known as **DIANA (Divise Analysis)** and it works in a top-down manner. The algorithm is an inverse order of AGNES. It begins with the root, in which all objects are included in a single cluster. At each step of iteration, the most heterogeneous cluster is divided into two. The process is iterated until all objects are in their own cluster (see figure below).

![alt text](http://www.sthda.com/sthda/RDoc/images/hierarchical-clustering-agnes-diana.png "AGNES vs DIANA")

**_Agglomerative clustering is good at identifying small clusters. Divisive hierarchical clustering is good at identifying large clusters._**

```{r}
#------------ DIVISIVE CLUSTERING ------------#
divisive.clust <- diana(gower.dist, 
                  diss = TRUE, keep.diss = FALSE)
divisive.clust$dc
pltree(divisive.clust, main = "Divisive")
```

```{r}
#------------ AGGLOMERATIVE CLUSTERING ------------#
# “complete”, “average”, “single”, “ward.D”
par(mfrow=c(2,2))
aggl.clust.c <- hclust(gower.dist, method = "complete")
aggl.clust.a <- hclust(gower.dist, method = "average")
aggl.clust.s <- hclust(gower.dist, method = "single")
aggl.clust.w <- hclust(gower.dist, method = "ward.D")
plot(aggl.clust.c,
     main = "Agglomerative, complete linkages")
plot(aggl.clust.a,
     main = "Agglomerative, average linkages")
plot(aggl.clust.s,
     main = "Agglomerative, single linkages")
plot(aggl.clust.w,
     main = "Agglomerative, ward linkages")
```

**Assess strength of the clusters**
```{r}
library(purrr)
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

# function to compute coefficient
ac <- function(x) {
  agnes(gower.dist, diss = TRUE, method = x)$ac
}

map(m, ac)
```
**Silhouette analysis**
```{r}
library(factoextra)
# sub_grp <- cutree(aggl.clust.w, k = 3)

# Number of members in each cluster
# table(sub_grp)
# fviz_nbclust(as.matrix(gower.dist), FUN = hcut, method = "silhouette")
fviz_nbclust(df_subset, FUN = kmeans, method = "silhouette")

```
<h2>References</h2>
1. https://www.r-bloggers.com/clustering-mixed-data-types-in-r/
2. https://towardsdatascience.com/hierarchical-clustering-on-categorical-data-in-r-a27e578f2995
